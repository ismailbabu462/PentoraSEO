{"version":3,"sources":["../../../../../../Desktop/pentoraSEO/src/app/tools/metin-karsilastirma/page.tsx","../../../../../../Desktop/pentoraSEO/node_modules/diff/libesm/diff/base.js","../../../../../../Desktop/pentoraSEO/node_modules/diff/libesm/util/string.js","../../../../../../Desktop/pentoraSEO/node_modules/diff/libesm/diff/word.js","../../../../../../Desktop/pentoraSEO/node_modules/diff/libesm/util/params.js","../../../../../../Desktop/pentoraSEO/node_modules/diff/libesm/diff/line.js","../../../../../../Desktop/pentoraSEO/node_modules/diff/libesm/diff/character.js"],"sourcesContent":["\"use client\";\r\n\r\nimport { useState, useMemo } from \"react\";\r\nimport { ToolLayout } from \"@/components/ToolLayout\";\r\nimport { getToolBySlug } from \"@/data/tools\";\r\nimport * as Diff from \"diff\";\r\n\r\nconst tool = getToolBySlug(\"metin-karsilastirma\")!;\r\n\r\ntype DiffMode = \"words\" | \"lines\" | \"chars\";\r\n\r\nexport default function MetinKarsilastirmaPage() {\r\n    const [text1, setText1] = useState(\"\");\r\n    const [text2, setText2] = useState(\"\");\r\n    const [mode, setMode] = useState<DiffMode>(\"words\");\r\n\r\n    const diffResult = useMemo(() => {\r\n        if (!text1 && !text2) return [];\r\n\r\n        switch (mode) {\r\n            case \"words\":\r\n                return Diff.diffWords(text1, text2);\r\n            case \"lines\":\r\n                return Diff.diffLines(text1, text2);\r\n            case \"chars\":\r\n                return Diff.diffChars(text1, text2);\r\n            default:\r\n                return [];\r\n        }\r\n    }, [text1, text2, mode]);\r\n\r\n    const stats = useMemo(() => {\r\n        let added = 0;\r\n        let removed = 0;\r\n        let unchanged = 0;\r\n\r\n        diffResult.forEach((part) => {\r\n            const count = part.value.length;\r\n            if (part.added) added += count;\r\n            else if (part.removed) removed += count;\r\n            else unchanged += count;\r\n        });\r\n\r\n        return { added, removed, unchanged };\r\n    }, [diffResult]);\r\n\r\n    return (\r\n        <ToolLayout tool={tool}>\r\n            {/* Mode Selection */}\r\n            <div className=\"flex items-center gap-4 mb-6\">\r\n                <span className=\"text-sm font-medium text-gray-700 dark:text-gray-300\">\r\n                    Karşılaştırma Modu:\r\n                </span>\r\n                <div className=\"flex gap-2\">\r\n                    {[\r\n                        { id: \"words\", name: \"Kelime\" },\r\n                        { id: \"lines\", name: \"Satır\" },\r\n                        { id: \"chars\", name: \"Karakter\" },\r\n                    ].map((m) => (\r\n                        <button\r\n                            key={m.id}\r\n                            onClick={() => setMode(m.id as DiffMode)}\r\n                            className={`px-4 py-2 rounded-lg text-sm font-medium transition-all ${mode === m.id\r\n                                    ? \"bg-brand-500 text-white\"\r\n                                    : \"bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700\"\r\n                                }`}\r\n                        >\r\n                            {m.name}\r\n                        </button>\r\n                    ))}\r\n                </div>\r\n            </div>\r\n\r\n            {/* Input Grid */}\r\n            <div className=\"grid md:grid-cols-2 gap-4 mb-6\">\r\n                <div>\r\n                    <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\r\n                        Orijinal Metin\r\n                    </label>\r\n                    <textarea\r\n                        value={text1}\r\n                        onChange={(e) => setText1(e.target.value)}\r\n                        placeholder=\"İlk metni buraya girin...\"\r\n                        className=\"input-base min-h-[200px] resize-y font-mono text-sm\"\r\n                    />\r\n                </div>\r\n                <div>\r\n                    <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\r\n                        Değiştirilmiş Metin\r\n                    </label>\r\n                    <textarea\r\n                        value={text2}\r\n                        onChange={(e) => setText2(e.target.value)}\r\n                        placeholder=\"İkinci metni buraya girin...\"\r\n                        className=\"input-base min-h-[200px] resize-y font-mono text-sm\"\r\n                    />\r\n                </div>\r\n            </div>\r\n\r\n            {/* Stats */}\r\n            {(text1 || text2) && (\r\n                <div className=\"flex gap-4 mb-6\">\r\n                    <div className=\"flex items-center gap-2\">\r\n                        <span className=\"w-3 h-3 rounded-full bg-green-500\"></span>\r\n                        <span className=\"text-sm text-gray-600 dark:text-gray-400\">\r\n                            Eklenen: {stats.added}\r\n                        </span>\r\n                    </div>\r\n                    <div className=\"flex items-center gap-2\">\r\n                        <span className=\"w-3 h-3 rounded-full bg-red-500\"></span>\r\n                        <span className=\"text-sm text-gray-600 dark:text-gray-400\">\r\n                            Silinen: {stats.removed}\r\n                        </span>\r\n                    </div>\r\n                    <div className=\"flex items-center gap-2\">\r\n                        <span className=\"w-3 h-3 rounded-full bg-gray-400\"></span>\r\n                        <span className=\"text-sm text-gray-600 dark:text-gray-400\">\r\n                            Değişmeyen: {stats.unchanged}\r\n                        </span>\r\n                    </div>\r\n                </div>\r\n            )}\r\n\r\n            {/* Diff Output */}\r\n            <div>\r\n                <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\r\n                    Farklar\r\n                </label>\r\n                <div className=\"p-4 rounded-xl bg-gray-50 dark:bg-gray-800/50 border border-gray-200 dark:border-gray-700 min-h-[150px] font-mono text-sm whitespace-pre-wrap overflow-auto\">\r\n                    {diffResult.length === 0 ? (\r\n                        <span className=\"text-gray-400\">\r\n                            Karşılaştırma sonuçları burada görünecek...\r\n                        </span>\r\n                    ) : (\r\n                        diffResult.map((part, index) => (\r\n                            <span\r\n                                key={index}\r\n                                className={\r\n                                    part.added\r\n                                        ? \"bg-green-200 dark:bg-green-900/50 text-green-800 dark:text-green-300\"\r\n                                        : part.removed\r\n                                            ? \"bg-red-200 dark:bg-red-900/50 text-red-800 dark:text-red-300 line-through\"\r\n                                            : \"\"\r\n                                }\r\n                            >\r\n                                {part.value}\r\n                            </span>\r\n                        ))\r\n                    )}\r\n                </div>\r\n            </div>\r\n\r\n            {/* Actions */}\r\n            <div className=\"flex gap-3 mt-4\">\r\n                <button\r\n                    onClick={() => {\r\n                        setText1(\"\");\r\n                        setText2(\"\");\r\n                    }}\r\n                    className=\"btn-secondary\"\r\n                    disabled={!text1 && !text2}\r\n                >\r\n                    Temizle\r\n                </button>\r\n                <button\r\n                    onClick={() => {\r\n                        const temp = text1;\r\n                        setText1(text2);\r\n                        setText2(temp);\r\n                    }}\r\n                    className=\"btn-secondary\"\r\n                    disabled={!text1 && !text2}\r\n                >\r\n                    <svg className=\"w-4 h-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\r\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4\" />\r\n                    </svg>\r\n                    Metinleri Değiştir\r\n                </button>\r\n            </div>\r\n        </ToolLayout>\r\n    );\r\n}\r\n","export default class Diff {\n    diff(oldStr, newStr, \n    // Type below is not accurate/complete - see above for full possibilities - but it compiles\n    options = {}) {\n        let callback;\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        else if ('callback' in options) {\n            callback = options.callback;\n        }\n        // Allow subclasses to massage the input prior to running\n        const oldString = this.castInput(oldStr, options);\n        const newString = this.castInput(newStr, options);\n        const oldTokens = this.removeEmpty(this.tokenize(oldString, options));\n        const newTokens = this.removeEmpty(this.tokenize(newString, options));\n        return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);\n    }\n    diffWithOptionsObj(oldTokens, newTokens, options, callback) {\n        var _a;\n        const done = (value) => {\n            value = this.postProcess(value, options);\n            if (callback) {\n                setTimeout(function () { callback(value); }, 0);\n                return undefined;\n            }\n            else {\n                return value;\n            }\n        };\n        const newLen = newTokens.length, oldLen = oldTokens.length;\n        let editLength = 1;\n        let maxEditLength = newLen + oldLen;\n        if (options.maxEditLength != null) {\n            maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n        }\n        const maxExecutionTime = (_a = options.timeout) !== null && _a !== void 0 ? _a : Infinity;\n        const abortAfterTimestamp = Date.now() + maxExecutionTime;\n        const bestPath = [{ oldPos: -1, lastComponent: undefined }];\n        // Seed editLength = 0, i.e. the content starts with the same values\n        let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);\n        if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n            // Identity per the equality and tokenizer\n            return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));\n        }\n        // Once we hit the right edge of the edit graph on some diagonal k, we can\n        // definitely reach the end of the edit graph in no more than k edits, so\n        // there's no point in considering any moves to diagonal k+1 any more (from\n        // which we're guaranteed to need at least k+1 more edits).\n        // Similarly, once we've reached the bottom of the edit graph, there's no\n        // point considering moves to lower diagonals.\n        // We record this fact by setting minDiagonalToConsider and\n        // maxDiagonalToConsider to some finite value once we've hit the edge of\n        // the edit graph.\n        // This optimization is not faithful to the original algorithm presented in\n        // Myers's paper, which instead pointlessly extends D-paths off the end of\n        // the edit graph - see page 7 of Myers's paper which notes this point\n        // explicitly and illustrates it with a diagram. This has major performance\n        // implications for some common scenarios. For instance, to compute a diff\n        // where the new text simply appends d characters on the end of the\n        // original text of length n, the true Myers algorithm will take O(n+d^2)\n        // time while this optimization needs only O(n+d) time.\n        let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;\n        // Main worker method. checks all permutations of a given edit length for acceptance.\n        const execEditLength = () => {\n            for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {\n                let basePath;\n                const removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];\n                if (removePath) {\n                    // No one else is going to attempt to use this value, clear it\n                    // @ts-expect-error - perf optimisation. This type-violating value will never be read.\n                    bestPath[diagonalPath - 1] = undefined;\n                }\n                let canAdd = false;\n                if (addPath) {\n                    // what newPos will be after we do an insertion:\n                    const addPathNewPos = addPath.oldPos - diagonalPath;\n                    canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n                }\n                const canRemove = removePath && removePath.oldPos + 1 < oldLen;\n                if (!canAdd && !canRemove) {\n                    // If this path is a terminal then prune\n                    // @ts-expect-error - perf optimisation. This type-violating value will never be read.\n                    bestPath[diagonalPath] = undefined;\n                    continue;\n                }\n                // Select the diagonal that we want to branch from. We select the prior\n                // path whose position in the old string is the farthest from the origin\n                // and does not pass the bounds of the diff graph\n                if (!canRemove || (canAdd && removePath.oldPos < addPath.oldPos)) {\n                    basePath = this.addToPath(addPath, true, false, 0, options);\n                }\n                else {\n                    basePath = this.addToPath(removePath, false, true, 1, options);\n                }\n                newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options);\n                if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n                    // If we have hit the end of both strings, then we are done\n                    return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;\n                }\n                else {\n                    bestPath[diagonalPath] = basePath;\n                    if (basePath.oldPos + 1 >= oldLen) {\n                        maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n                    }\n                    if (newPos + 1 >= newLen) {\n                        minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n                    }\n                }\n            }\n            editLength++;\n        };\n        // Performs the length of edit iteration. Is a bit fugly as this has to support the\n        // sync and async mode which is never fun. Loops over execEditLength until a value\n        // is produced, or until the edit length exceeds options.maxEditLength (if given),\n        // in which case it will return undefined.\n        if (callback) {\n            (function exec() {\n                setTimeout(function () {\n                    if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n                        return callback(undefined);\n                    }\n                    if (!execEditLength()) {\n                        exec();\n                    }\n                }, 0);\n            }());\n        }\n        else {\n            while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n                const ret = execEditLength();\n                if (ret) {\n                    return ret;\n                }\n            }\n        }\n    }\n    addToPath(path, added, removed, oldPosInc, options) {\n        const last = path.lastComponent;\n        if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {\n            return {\n                oldPos: path.oldPos + oldPosInc,\n                lastComponent: { count: last.count + 1, added: added, removed: removed, previousComponent: last.previousComponent }\n            };\n        }\n        else {\n            return {\n                oldPos: path.oldPos + oldPosInc,\n                lastComponent: { count: 1, added: added, removed: removed, previousComponent: last }\n            };\n        }\n    }\n    extractCommon(basePath, newTokens, oldTokens, diagonalPath, options) {\n        const newLen = newTokens.length, oldLen = oldTokens.length;\n        let oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;\n        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)) {\n            newPos++;\n            oldPos++;\n            commonCount++;\n            if (options.oneChangePerToken) {\n                basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: false, removed: false };\n            }\n        }\n        if (commonCount && !options.oneChangePerToken) {\n            basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false };\n        }\n        basePath.oldPos = oldPos;\n        return newPos;\n    }\n    equals(left, right, options) {\n        if (options.comparator) {\n            return options.comparator(left, right);\n        }\n        else {\n            return left === right\n                || (!!options.ignoreCase && left.toLowerCase() === right.toLowerCase());\n        }\n    }\n    removeEmpty(array) {\n        const ret = [];\n        for (let i = 0; i < array.length; i++) {\n            if (array[i]) {\n                ret.push(array[i]);\n            }\n        }\n        return ret;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    castInput(value, options) {\n        return value;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    tokenize(value, options) {\n        return Array.from(value);\n    }\n    join(chars) {\n        // Assumes ValueT is string, which is the case for most subclasses.\n        // When it's false, e.g. in diffArrays, this method needs to be overridden (e.g. with a no-op)\n        // Yes, the casts are verbose and ugly, because this pattern - of having the base class SORT OF\n        // assume tokens and values are strings, but not completely - is weird and janky.\n        return chars.join('');\n    }\n    postProcess(changeObjects, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    options) {\n        return changeObjects;\n    }\n    get useLongestToken() {\n        return false;\n    }\n    buildValues(lastComponent, newTokens, oldTokens) {\n        // First we convert our linked list of components in reverse order to an\n        // array in the right order:\n        const components = [];\n        let nextComponent;\n        while (lastComponent) {\n            components.push(lastComponent);\n            nextComponent = lastComponent.previousComponent;\n            delete lastComponent.previousComponent;\n            lastComponent = nextComponent;\n        }\n        components.reverse();\n        const componentLen = components.length;\n        let componentPos = 0, newPos = 0, oldPos = 0;\n        for (; componentPos < componentLen; componentPos++) {\n            const component = components[componentPos];\n            if (!component.removed) {\n                if (!component.added && this.useLongestToken) {\n                    let value = newTokens.slice(newPos, newPos + component.count);\n                    value = value.map(function (value, i) {\n                        const oldValue = oldTokens[oldPos + i];\n                        return oldValue.length > value.length ? oldValue : value;\n                    });\n                    component.value = this.join(value);\n                }\n                else {\n                    component.value = this.join(newTokens.slice(newPos, newPos + component.count));\n                }\n                newPos += component.count;\n                // Common case\n                if (!component.added) {\n                    oldPos += component.count;\n                }\n            }\n            else {\n                component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));\n                oldPos += component.count;\n            }\n        }\n        return components;\n    }\n}\n","export function longestCommonPrefix(str1, str2) {\n    let i;\n    for (i = 0; i < str1.length && i < str2.length; i++) {\n        if (str1[i] != str2[i]) {\n            return str1.slice(0, i);\n        }\n    }\n    return str1.slice(0, i);\n}\nexport function longestCommonSuffix(str1, str2) {\n    let i;\n    // Unlike longestCommonPrefix, we need a special case to handle all scenarios\n    // where we return the empty string since str1.slice(-0) will return the\n    // entire string.\n    if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {\n        return '';\n    }\n    for (i = 0; i < str1.length && i < str2.length; i++) {\n        if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {\n            return str1.slice(-i);\n        }\n    }\n    return str1.slice(-i);\n}\nexport function replacePrefix(string, oldPrefix, newPrefix) {\n    if (string.slice(0, oldPrefix.length) != oldPrefix) {\n        throw Error(`string ${JSON.stringify(string)} doesn't start with prefix ${JSON.stringify(oldPrefix)}; this is a bug`);\n    }\n    return newPrefix + string.slice(oldPrefix.length);\n}\nexport function replaceSuffix(string, oldSuffix, newSuffix) {\n    if (!oldSuffix) {\n        return string + newSuffix;\n    }\n    if (string.slice(-oldSuffix.length) != oldSuffix) {\n        throw Error(`string ${JSON.stringify(string)} doesn't end with suffix ${JSON.stringify(oldSuffix)}; this is a bug`);\n    }\n    return string.slice(0, -oldSuffix.length) + newSuffix;\n}\nexport function removePrefix(string, oldPrefix) {\n    return replacePrefix(string, oldPrefix, '');\n}\nexport function removeSuffix(string, oldSuffix) {\n    return replaceSuffix(string, oldSuffix, '');\n}\nexport function maximumOverlap(string1, string2) {\n    return string2.slice(0, overlapCount(string1, string2));\n}\n// Nicked from https://stackoverflow.com/a/60422853/1709587\nfunction overlapCount(a, b) {\n    // Deal with cases where the strings differ in length\n    let startA = 0;\n    if (a.length > b.length) {\n        startA = a.length - b.length;\n    }\n    let endB = b.length;\n    if (a.length < b.length) {\n        endB = a.length;\n    }\n    // Create a back-reference for each index\n    //   that should be followed in case of a mismatch.\n    //   We only need B to make these references:\n    const map = Array(endB);\n    let k = 0; // Index that lags behind j\n    map[0] = 0;\n    for (let j = 1; j < endB; j++) {\n        if (b[j] == b[k]) {\n            map[j] = map[k]; // skip over the same character (optional optimisation)\n        }\n        else {\n            map[j] = k;\n        }\n        while (k > 0 && b[j] != b[k]) {\n            k = map[k];\n        }\n        if (b[j] == b[k]) {\n            k++;\n        }\n    }\n    // Phase 2: use these references while iterating over A\n    k = 0;\n    for (let i = startA; i < a.length; i++) {\n        while (k > 0 && a[i] != b[k]) {\n            k = map[k];\n        }\n        if (a[i] == b[k]) {\n            k++;\n        }\n    }\n    return k;\n}\n/**\n * Returns true if the string consistently uses Windows line endings.\n */\nexport function hasOnlyWinLineEndings(string) {\n    return string.includes('\\r\\n') && !string.startsWith('\\n') && !string.match(/[^\\r]\\n/);\n}\n/**\n * Returns true if the string consistently uses Unix line endings.\n */\nexport function hasOnlyUnixLineEndings(string) {\n    return !string.includes('\\r\\n') && string.includes('\\n');\n}\nexport function trailingWs(string) {\n    // Yes, this looks overcomplicated and dumb - why not replace the whole function with\n    //     return string match(/\\s*$/)[0]\n    // you ask? Because:\n    // 1. the trap described at https://markamery.com/blog/quadratic-time-regexes/ would mean doing\n    //    this would cause this function to take O(n²) time in the worst case (specifically when\n    //    there is a massive run of NON-TRAILING whitespace in `string`), and\n    // 2. the fix proposed in the same blog post, of using a negative lookbehind, is incompatible\n    //    with old Safari versions that we'd like to not break if possible (see\n    //    https://github.com/kpdecker/jsdiff/pull/550)\n    // It feels absurd to do this with an explicit loop instead of a regex, but I really can't see a\n    // better way that doesn't result in broken behaviour.\n    let i;\n    for (i = string.length - 1; i >= 0; i--) {\n        if (!string[i].match(/\\s/)) {\n            break;\n        }\n    }\n    return string.substring(i + 1);\n}\nexport function leadingWs(string) {\n    // Thankfully the annoying considerations described in trailingWs don't apply here:\n    const match = string.match(/^\\s*/);\n    return match ? match[0] : '';\n}\n","import Diff from './base.js';\nimport { longestCommonPrefix, longestCommonSuffix, replacePrefix, replaceSuffix, removePrefix, removeSuffix, maximumOverlap, leadingWs, trailingWs } from '../util/string.js';\n// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\nconst extendedWordChars = 'a-zA-Z0-9_\\\\u{C0}-\\\\u{FF}\\\\u{D8}-\\\\u{F6}\\\\u{F8}-\\\\u{2C6}\\\\u{2C8}-\\\\u{2D7}\\\\u{2DE}-\\\\u{2FF}\\\\u{1E00}-\\\\u{1EFF}';\n// Each token is one of the following:\n// - A punctuation mark plus the surrounding whitespace\n// - A word plus the surrounding whitespace\n// - Pure whitespace (but only in the special case where this the entire text\n//   is just whitespace)\n//\n// We have to include surrounding whitespace in the tokens because the two\n// alternative approaches produce horribly broken results:\n// * If we just discard the whitespace, we can't fully reproduce the original\n//   text from the sequence of tokens and any attempt to render the diff will\n//   get the whitespace wrong.\n// * If we have separate tokens for whitespace, then in a typical text every\n//   second token will be a single space character. But this often results in\n//   the optimal diff between two texts being a perverse one that preserves\n//   the spaces between words but deletes and reinserts actual common words.\n//   See https://github.com/kpdecker/jsdiff/issues/160#issuecomment-1866099640\n//   for an example.\n//\n// Keeping the surrounding whitespace of course has implications for .equals\n// and .join, not just .tokenize.\n// This regex does NOT fully implement the tokenization rules described above.\n// Instead, it gives runs of whitespace their own \"token\". The tokenize method\n// then handles stitching whitespace tokens onto adjacent word or punctuation\n// tokens.\nconst tokenizeIncludingWhitespace = new RegExp(`[${extendedWordChars}]+|\\\\s+|[^${extendedWordChars}]`, 'ug');\nclass WordDiff extends Diff {\n    equals(left, right, options) {\n        if (options.ignoreCase) {\n            left = left.toLowerCase();\n            right = right.toLowerCase();\n        }\n        return left.trim() === right.trim();\n    }\n    tokenize(value, options = {}) {\n        let parts;\n        if (options.intlSegmenter) {\n            const segmenter = options.intlSegmenter;\n            if (segmenter.resolvedOptions().granularity != 'word') {\n                throw new Error('The segmenter passed must have a granularity of \"word\"');\n            }\n            parts = Array.from(segmenter.segment(value), segment => segment.segment);\n        }\n        else {\n            parts = value.match(tokenizeIncludingWhitespace) || [];\n        }\n        const tokens = [];\n        let prevPart = null;\n        parts.forEach(part => {\n            if ((/\\s/).test(part)) {\n                if (prevPart == null) {\n                    tokens.push(part);\n                }\n                else {\n                    tokens.push(tokens.pop() + part);\n                }\n            }\n            else if (prevPart != null && (/\\s/).test(prevPart)) {\n                if (tokens[tokens.length - 1] == prevPart) {\n                    tokens.push(tokens.pop() + part);\n                }\n                else {\n                    tokens.push(prevPart + part);\n                }\n            }\n            else {\n                tokens.push(part);\n            }\n            prevPart = part;\n        });\n        return tokens;\n    }\n    join(tokens) {\n        // Tokens being joined here will always have appeared consecutively in the\n        // same text, so we can simply strip off the leading whitespace from all the\n        // tokens except the first (and except any whitespace-only tokens - but such\n        // a token will always be the first and only token anyway) and then join them\n        // and the whitespace around words and punctuation will end up correct.\n        return tokens.map((token, i) => {\n            if (i == 0) {\n                return token;\n            }\n            else {\n                return token.replace((/^\\s+/), '');\n            }\n        }).join('');\n    }\n    postProcess(changes, options) {\n        if (!changes || options.oneChangePerToken) {\n            return changes;\n        }\n        let lastKeep = null;\n        // Change objects representing any insertion or deletion since the last\n        // \"keep\" change object. There can be at most one of each.\n        let insertion = null;\n        let deletion = null;\n        changes.forEach(change => {\n            if (change.added) {\n                insertion = change;\n            }\n            else if (change.removed) {\n                deletion = change;\n            }\n            else {\n                if (insertion || deletion) { // May be false at start of text\n                    dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);\n                }\n                lastKeep = change;\n                insertion = null;\n                deletion = null;\n            }\n        });\n        if (insertion || deletion) {\n            dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);\n        }\n        return changes;\n    }\n}\nexport const wordDiff = new WordDiff();\nexport function diffWords(oldStr, newStr, options) {\n    // This option has never been documented and never will be (it's clearer to\n    // just call `diffWordsWithSpace` directly if you need that behavior), but\n    // has existed in jsdiff for a long time, so we retain support for it here\n    // for the sake of backwards compatibility.\n    if ((options === null || options === void 0 ? void 0 : options.ignoreWhitespace) != null && !options.ignoreWhitespace) {\n        return diffWordsWithSpace(oldStr, newStr, options);\n    }\n    return wordDiff.diff(oldStr, newStr, options);\n}\nfunction dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {\n    // Before returning, we tidy up the leading and trailing whitespace of the\n    // change objects to eliminate cases where trailing whitespace in one object\n    // is repeated as leading whitespace in the next.\n    // Below are examples of the outcomes we want here to explain the code.\n    // I=insert, K=keep, D=delete\n    // 1. diffing 'foo bar baz' vs 'foo baz'\n    //    Prior to cleanup, we have K:'foo ' D:' bar ' K:' baz'\n    //    After cleanup, we want:   K:'foo ' D:'bar ' K:'baz'\n    //\n    // 2. Diffing 'foo bar baz' vs 'foo qux baz'\n    //    Prior to cleanup, we have K:'foo ' D:' bar ' I:' qux ' K:' baz'\n    //    After cleanup, we want K:'foo ' D:'bar' I:'qux' K:' baz'\n    //\n    // 3. Diffing 'foo\\nbar baz' vs 'foo baz'\n    //    Prior to cleanup, we have K:'foo ' D:'\\nbar ' K:' baz'\n    //    After cleanup, we want K'foo' D:'\\nbar' K:' baz'\n    //\n    // 4. Diffing 'foo baz' vs 'foo\\nbar baz'\n    //    Prior to cleanup, we have K:'foo\\n' I:'\\nbar ' K:' baz'\n    //    After cleanup, we ideally want K'foo' I:'\\nbar' K:' baz'\n    //    but don't actually manage this currently (the pre-cleanup change\n    //    objects don't contain enough information to make it possible).\n    //\n    // 5. Diffing 'foo   bar baz' vs 'foo  baz'\n    //    Prior to cleanup, we have K:'foo  ' D:'   bar ' K:'  baz'\n    //    After cleanup, we want K:'foo  ' D:' bar ' K:'baz'\n    //\n    // Our handling is unavoidably imperfect in the case where there's a single\n    // indel between keeps and the whitespace has changed. For instance, consider\n    // diffing 'foo\\tbar\\nbaz' vs 'foo baz'. Unless we create an extra change\n    // object to represent the insertion of the space character (which isn't even\n    // a token), we have no way to avoid losing information about the texts'\n    // original whitespace in the result we return. Still, we do our best to\n    // output something that will look sensible if we e.g. print it with\n    // insertions in green and deletions in red.\n    // Between two \"keep\" change objects (or before the first or after the last\n    // change object), we can have either:\n    // * A \"delete\" followed by an \"insert\"\n    // * Just an \"insert\"\n    // * Just a \"delete\"\n    // We handle the three cases separately.\n    if (deletion && insertion) {\n        const oldWsPrefix = leadingWs(deletion.value);\n        const oldWsSuffix = trailingWs(deletion.value);\n        const newWsPrefix = leadingWs(insertion.value);\n        const newWsSuffix = trailingWs(insertion.value);\n        if (startKeep) {\n            const commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);\n            startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);\n            deletion.value = removePrefix(deletion.value, commonWsPrefix);\n            insertion.value = removePrefix(insertion.value, commonWsPrefix);\n        }\n        if (endKeep) {\n            const commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);\n            endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);\n            deletion.value = removeSuffix(deletion.value, commonWsSuffix);\n            insertion.value = removeSuffix(insertion.value, commonWsSuffix);\n        }\n    }\n    else if (insertion) {\n        // The whitespaces all reflect what was in the new text rather than\n        // the old, so we essentially have no information about whitespace\n        // insertion or deletion. We just want to dedupe the whitespace.\n        // We do that by having each change object keep its trailing\n        // whitespace and deleting duplicate leading whitespace where\n        // present.\n        if (startKeep) {\n            const ws = leadingWs(insertion.value);\n            insertion.value = insertion.value.substring(ws.length);\n        }\n        if (endKeep) {\n            const ws = leadingWs(endKeep.value);\n            endKeep.value = endKeep.value.substring(ws.length);\n        }\n        // otherwise we've got a deletion and no insertion\n    }\n    else if (startKeep && endKeep) {\n        const newWsFull = leadingWs(endKeep.value), delWsStart = leadingWs(deletion.value), delWsEnd = trailingWs(deletion.value);\n        // Any whitespace that comes straight after startKeep in both the old and\n        // new texts, assign to startKeep and remove from the deletion.\n        const newWsStart = longestCommonPrefix(newWsFull, delWsStart);\n        deletion.value = removePrefix(deletion.value, newWsStart);\n        // Any whitespace that comes straight before endKeep in both the old and\n        // new texts, and hasn't already been assigned to startKeep, assign to\n        // endKeep and remove from the deletion.\n        const newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);\n        deletion.value = removeSuffix(deletion.value, newWsEnd);\n        endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);\n        // If there's any whitespace from the new text that HASN'T already been\n        // assigned, assign it to the start:\n        startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));\n    }\n    else if (endKeep) {\n        // We are at the start of the text. Preserve all the whitespace on\n        // endKeep, and just remove whitespace from the end of deletion to the\n        // extent that it overlaps with the start of endKeep.\n        const endKeepWsPrefix = leadingWs(endKeep.value);\n        const deletionWsSuffix = trailingWs(deletion.value);\n        const overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);\n        deletion.value = removeSuffix(deletion.value, overlap);\n    }\n    else if (startKeep) {\n        // We are at the END of the text. Preserve all the whitespace on\n        // startKeep, and just remove whitespace from the start of deletion to\n        // the extent that it overlaps with the end of startKeep.\n        const startKeepWsSuffix = trailingWs(startKeep.value);\n        const deletionWsPrefix = leadingWs(deletion.value);\n        const overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);\n        deletion.value = removePrefix(deletion.value, overlap);\n    }\n}\nclass WordsWithSpaceDiff extends Diff {\n    tokenize(value) {\n        // Slightly different to the tokenizeIncludingWhitespace regex used above in\n        // that this one treats each individual newline as a distinct tokens, rather\n        // than merging them into other surrounding whitespace. This was requested\n        // in https://github.com/kpdecker/jsdiff/issues/180 &\n        //    https://github.com/kpdecker/jsdiff/issues/211\n        const regex = new RegExp(`(\\\\r?\\\\n)|[${extendedWordChars}]+|[^\\\\S\\\\n\\\\r]+|[^${extendedWordChars}]`, 'ug');\n        return value.match(regex) || [];\n    }\n}\nexport const wordsWithSpaceDiff = new WordsWithSpaceDiff();\nexport function diffWordsWithSpace(oldStr, newStr, options) {\n    return wordsWithSpaceDiff.diff(oldStr, newStr, options);\n}\n","export function generateOptions(options, defaults) {\n    if (typeof options === 'function') {\n        defaults.callback = options;\n    }\n    else if (options) {\n        for (const name in options) {\n            /* istanbul ignore else */\n            if (Object.prototype.hasOwnProperty.call(options, name)) {\n                defaults[name] = options[name];\n            }\n        }\n    }\n    return defaults;\n}\n","import Diff from './base.js';\nimport { generateOptions } from '../util/params.js';\nclass LineDiff extends Diff {\n    constructor() {\n        super(...arguments);\n        this.tokenize = tokenize;\n    }\n    equals(left, right, options) {\n        // If we're ignoring whitespace, we need to normalise lines by stripping\n        // whitespace before checking equality. (This has an annoying interaction\n        // with newlineIsToken that requires special handling: if newlines get their\n        // own token, then we DON'T want to trim the *newline* tokens down to empty\n        // strings, since this would cause us to treat whitespace-only line content\n        // as equal to a separator between lines, which would be weird and\n        // inconsistent with the documented behavior of the options.)\n        if (options.ignoreWhitespace) {\n            if (!options.newlineIsToken || !left.includes('\\n')) {\n                left = left.trim();\n            }\n            if (!options.newlineIsToken || !right.includes('\\n')) {\n                right = right.trim();\n            }\n        }\n        else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {\n            if (left.endsWith('\\n')) {\n                left = left.slice(0, -1);\n            }\n            if (right.endsWith('\\n')) {\n                right = right.slice(0, -1);\n            }\n        }\n        return super.equals(left, right, options);\n    }\n}\nexport const lineDiff = new LineDiff();\nexport function diffLines(oldStr, newStr, options) {\n    return lineDiff.diff(oldStr, newStr, options);\n}\nexport function diffTrimmedLines(oldStr, newStr, options) {\n    options = generateOptions(options, { ignoreWhitespace: true });\n    return lineDiff.diff(oldStr, newStr, options);\n}\n// Exported standalone so it can be used from jsonDiff too.\nexport function tokenize(value, options) {\n    if (options.stripTrailingCr) {\n        // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n        value = value.replace(/\\r\\n/g, '\\n');\n    }\n    const retLines = [], linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n    // Ignore the final empty token that occurs if the string ends with a new line\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n        linesAndNewlines.pop();\n    }\n    // Merge the content and line separators into single tokens\n    for (let i = 0; i < linesAndNewlines.length; i++) {\n        const line = linesAndNewlines[i];\n        if (i % 2 && !options.newlineIsToken) {\n            retLines[retLines.length - 1] += line;\n        }\n        else {\n            retLines.push(line);\n        }\n    }\n    return retLines;\n}\n","import Diff from './base.js';\nclass CharacterDiff extends Diff {\n}\nexport const characterDiff = new CharacterDiff();\nexport function diffChars(oldStr, newStr, options) {\n    return characterDiff.diff(oldStr, newStr, options);\n}\n"],"names":[],"mappings":"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","ignoreList":[1,2,3,4,5,6]}